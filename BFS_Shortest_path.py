# Explanation: For this I have used BFS algorithm. I have used the Normal BFS and stored the value of Parents of every vertex. 
# After that from the userâ€™s desired node I have printed the parent of that vertex and the grandparent of the vertex till it comes to the beginning.

# -*- coding: utf-8 -*-
"""task5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T6_V9Bnq5OuB2W5XmAaxmQ1niMsitW-9
"""

import threading
import queue #inporting

inp = open('/content/input5.txt',"r")
out = open('/content/output5.txt',"w")

x,y,z = list(map(int,inp.readline().split()))#vertice,edges,desired
adjL = [[] for i in range(x+1)] #creating adj list

for i in range(y):
  a,b = list(map(int,inp.readline().split()))
  adjL[a].append(b) #inputing all nodes into adj list
  adjL[b].append(a)

def BFS(G,S,C): #G = adhL and S = 1 , 1 is our fisrt vertex
  vertex = [0] * (x+1) #this list says visited or not
  distance = [0] * (x+1) #distance from first vertex
  parent = [0] * (x+1)  #parents of every vertex
  Q = queue.Queue()
  vertex[S] = 1 #initializing the 1st vertex as visited
  Q.put(S) #enqueue first index


  while Q.qsize() != 0: #size compare of queue
    u = Q.get() #get function does the work of deqeue as well

    for i in G[u]:
      if vertex[i] ==0:
        vertex[i] = 1 #says , I visited
        distance[i] = distance[u] + 1 #from parent distance +1
        parent[i] = u #adding the parent
        Q.put(i) #enqueing new vertex

  out.write(f"Time: {distance[C]}\n")
  out.write(f"Shortest Path:")

  final = [C] #final path
  while C !=1:
    final.append(parent[C])
    C = parent[C]

  for i in range(len(final)-1,-1,-1): #reverse print
    out.write(f" {final[i]}")


BFS(adjL,1,z) # calling the BFS, z = destination

inp.close()
out.close()
